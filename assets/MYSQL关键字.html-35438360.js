import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,a as n}from"./app-f3cf3236.js";const s={},l=n(`<h2 id="where-和-having-的区别" tabindex="-1"><a class="header-anchor" href="#where-和-having-的区别" aria-hidden="true">#</a> where 和 having 的区别</h2><p>where和having是两种常用的SQL语句，用于对数据进行筛选和过滤。它们的区别主要有以下几点：</p><ul><li>where子句在分组和聚合之前对数据行进行筛选，而having子句在分组和聚合之后对数据行进行筛选。</li><li>where子句中不能使用聚合函数，如sum, count, max等，而having子句中可以使用聚合函数。</li><li>where子句适用于所有类型的查询，包括单表查询，多表连接查询，内连接查询，外连接查询等，而having子句一般只用于分组查询，即带有group by子句的查询。</li><li>where子句和having子句可以组合使用，但是一般建议将连接条件放在where子句中，将分组条件放在having子句中，这样可以提高查询效率和可读性。</li></ul><p>下面是一个简单的例子，假设有一个员工表employee，有三个字段emp_id, dept_id, salary，表示员工编号，部门编号和薪水。我们想要查询每个部门的平均薪水，并且只显示平均薪水大于10000的部门。我们可以使用以下SQL语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 使用where和having组合</span>
<span class="token keyword">select</span> dept_id<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">as</span> avg_salary
<span class="token keyword">from</span> employee
<span class="token keyword">where</span> salary <span class="token operator">&gt;</span> <span class="token number">5000</span> <span class="token comment">-- 过滤掉薪水小于5000的员工</span>
<span class="token keyword">group</span> <span class="token keyword">by</span> dept_id <span class="token comment">-- 按照部门编号分组</span>
<span class="token keyword">having</span> <span class="token function">avg</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10000</span> <span class="token comment">-- 过滤掉平均薪水小于10000的部门</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="innerjoin、leftjoin、rightjoin、union-的区别" tabindex="-1"><a class="header-anchor" href="#innerjoin、leftjoin、rightjoin、union-的区别" aria-hidden="true">#</a> innerjoin、leftjoin、rightjoin、union 的区别</h2><p>inner join, left join, right join和union都是SQL语句中常用的连接操作，用于将两个或多个表的数据进行合并和查询。它们的区别主要有以下几点：</p><ul><li>inner join是指只返回两个表中满足连接条件的记录，也就是两个表的交集部分。例如，如果我们有两个表A和B，分别有以下数据：</li></ul><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">name</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">a</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">b</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">c</td></tr></tbody></table><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">age</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">10</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">20</td></tr><tr><td style="text-align:left;">4</td><td style="text-align:left;">30</td></tr></tbody></table><p>那么我们可以使用以下SQL语句来进行inner join：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span> A<span class="token punctuation">.</span>name<span class="token punctuation">,</span> B<span class="token punctuation">.</span>age
<span class="token keyword">from</span> A
<span class="token keyword">inner</span> <span class="token keyword">join</span> B
<span class="token keyword">on</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的结果是：</p><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">name</th><th style="text-align:left;">age</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">a</td><td style="text-align:left;">10</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">b</td><td style="text-align:left;">20</td></tr></tbody></table><p>可以看到，只有id为1和2的记录在两个表中都存在，所以只返回这两条记录。</p><ul><li>left join是指返回左表中的所有记录，以及右表中满足连接条件的记录，如果右表中没有匹配的记录，则用NULL填充。也就是说，左表是主表，右表是从表。例如，如果我们还是使用上面的两个表A和B，那么我们可以使用以下SQL语句来进行left join：</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span> A<span class="token punctuation">.</span>name<span class="token punctuation">,</span> B<span class="token punctuation">.</span>age
<span class="token keyword">from</span> A
<span class="token keyword">left</span> <span class="token keyword">join</span> B
<span class="token keyword">on</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的结果是：</p><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">name</th><th style="text-align:left;">age</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">a</td><td style="text-align:left;">10</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">b</td><td style="text-align:left;">20</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">c</td><td style="text-align:left;">NULL</td></tr></tbody></table><p>可以看到，左表A中的所有记录都返回了，而右表B中只有id为1和2的记录匹配了连接条件，所以只返回这两条记录，id为3的记录没有匹配的记录，所以用NULL填充。</p><ul><li>right join是指返回右表中的所有记录，以及左表中满足连接条件的记录，如果左表中没有匹配的记录，则用NULL填充。也就是说，右表是主表，左表是从表。它和left join是对称的。例如，如果我们还是使用上面的两个表A和B，那么我们可以使用以下SQL语句来进行right join：</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span> A<span class="token punctuation">.</span>name<span class="token punctuation">,</span> B<span class="token punctuation">.</span>age
<span class="token keyword">from</span> A
<span class="token keyword">right</span> <span class="token keyword">join</span> B
<span class="token keyword">on</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的结果是：</p><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">name</th><th style="text-align:left;">age</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">a</td><td style="text-align:left;">10</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">b</td><td style="text-align:left;">20</td></tr><tr><td style="text-align:left;">NULL</td><td style="text-align:left;">NULL</td><td style="text-align:left;">30</td></tr></tbody></table><p>可以看到，右表B中的所有记录都返回了，而左表A中只有id为1和2的记录匹配了连接条件，所以只返回这两条记录，id为4的记录没有匹配的记录，所以用NULL填充。</p><ul><li>union是指将两个或多个查询结果合并成一个结果集，并且去除重复的记录。例如，如果我们有两个查询语句Q1和Q2，分别返回以下结果：</li></ul><p>Q1:</p><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">name</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">a</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">b</td></tr></tbody></table><p>Q2:</p><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">name</th></tr></thead><tbody><tr><td style="text-align:left;">2</td><td style="text-align:left;">b</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">c</td></tr></tbody></table><p>那么我们可以使用以下SQL语句来进行union：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span> name <span class="token keyword">from</span> Q1
<span class="token keyword">union</span>
<span class="token keyword">select</span> id<span class="token punctuation">,</span> name <span class="token keyword">from</span> Q2<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的结果是：</p><table><thead><tr><th style="text-align:left;">id</th><th style="text-align:left;">name</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">a</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">b</td></tr><tr><td style="text-align:left;">3</td><td style="text-align:left;">c</td></tr></tbody></table><p>可以看到，两个查询结果中相同的记录（id为2）只返回了一次，而不同的记录都返回了。</p><h2 id="drop、turncate、delete-的区别" tabindex="-1"><a class="header-anchor" href="#drop、turncate、delete-的区别" aria-hidden="true">#</a> drop、turncate、delete 的区别</h2><p>drop, truncate和delete都是SQL语句中常用的删除操作，用于将表中的数据进行清除或移除。它们的区别主要有以下几点：</p><ul><li>drop是一个数据定义语言（DDL）命令，用于删除整个表或数据库，包括表的结构和数据。使用drop命令后，表或数据库将不存在，无法恢复。</li><li>truncate也是一个数据定义语言（DDL）命令，用于删除表中的所有数据，但保留表的结构。使用truncate命令后，表中的数据将被清空，但表的定义和索引等信息仍然存在。</li><li>delete是一个数据操纵语言（DML）命令，用于删除表中的一部分或全部数据，但不影响表的结构。使用delete命令后，表中的数据将被移除，但表的定义和索引等信息仍然存在。</li></ul><p>在性能上，drop是最快的，因为它只需要删除一次表或数据库的元数据信息；truncate次之，因为它只需要删除一次表中的所有数据；delete最慢，因为它需要逐行删除数据，并且可以使用where子句进行条件筛选。</p><p>在事务上，drop和truncate都是自动提交的，即执行后无法回滚；delete则可以回滚，因为它会记录每条删除的数据，并且可以使用事务控制语句进行提交或撤销。</p><p>在触发器上，drop和truncate都不会触发任何与表相关的触发器；delete则会触发与表相关的触发器，因为它会影响每条数据的状态。</p><h2 id="char-和-varchar-的区别-哪个索引效率更高" tabindex="-1"><a class="header-anchor" href="#char-和-varchar-的区别-哪个索引效率更高" aria-hidden="true">#</a> char 和 varchar 的区别，哪个索引效率更高？</h2><p>char和varchar是两种常用的字符数据类型，它们在存储方式和性能上有一些不同。</p><p>char是固定长度的字符数据类型，也就是说，无论存储多少个字符，它都会占用定义的最大长度的空间。例如，如果定义一个char(10)的列，那么无论存储一个字符还是十个字符，它都会占用10个字节的空间。如果存储的字符数少于最大长度，那么它会用空格填充剩余的空间。</p><p>varchar是可变长度的字符数据类型，也就是说，它会根据实际存储的字符数动态分配空间。例如，如果定义一个varchar(10)的列，那么存储一个字符只会占用一个字节的空间，存储十个字符才会占用十个字节的空间。另外，varchar还需要额外的一个或两个字节来存储实际的字符数。</p><p>在索引效率上，char和varchar有以下几点影响：</p><ul><li>char由于是固定长度的，所以在字符串操作上比较简单和快速，不需要进行长度检查和转换。因此，在进行索引比较时，char通常比varchar更快。</li><li>varchar由于是可变长度的，所以在字符串操作上比较复杂和慢速，需要进行长度检查和转换。因此，在进行索引比较时，varchar通常比char更慢。</li><li>char由于可能会产生很多空格填充，所以在存储空间上比较浪费，导致索引文件变大，影响索引效率。</li><li>varchar由于可以根据实际字符数节省空间，所以在存储空间上比较节省，导致索引文件变小，提高索引效率。</li></ul><p>char和varchar对索引效率的影响取决于实际存储的数据和查询条件。一般来说，如果数据是固定长度或接近固定长度，并且需要进行频繁的索引比较，那么使用char可能更合适；如果数据是可变长度或差异很大，并且需要节省存储空间和提高查询速度，那么使用varchar可能更合适。</p><h2 id="datetime-和-timestamp-的区别" tabindex="-1"><a class="header-anchor" href="#datetime-和-timestamp-的区别" aria-hidden="true">#</a> datetime 和 timestamp 的区别</h2><p>datetime和timestamp都是MySQL中常用的日期时间数据类型，它们在存储方式和功能上有一些不同</p><p>datetime是用于表示日期和时间的数据类型，它的格式是YYYY-MM-DD HH:MM:SS，它的支持范围是1000-01-01 00:00:00到9999-12-31 23:59:59。</p><p>datetime的特点是：</p><ul><li>它可以存储任意的日期和时间，不受时区的影响。</li><li>它占用8个字节的存储空间，不管实际存储的值有多长。</li><li>它可以使用默认值或函数来赋值，例如DEFAULT CURRENT_TIMESTAMP或ON UPDATE CURRENT_TIMESTAMP。</li></ul><p>timestamp也是用于表示日期和时间的数据类型，它的格式也是YYYY-MM-DD HH:MM:SS，但它的支持范围是1970-01-01 00:00:01 UTC到2038-01-19 03:14:07 UTC。</p><p>timestamp的特点是：</p><ul><li>它实际上是存储一个从1970年1月1日开始的秒数，它会根据时区进行转换，显示为本地时间。</li><li>它占用4个字节的存储空间，比datetime更节省空间。</li><li>它会自动赋值为当前时间，如果没有指定值或指定为NULL。</li></ul><p>datetime和timestamp在存储方式和功能上有以下几点区别：</p><ul><li>datetime可以存储更广泛的日期和时间范围，而timestamp只能存储有限的范围。</li><li>datetime不受时区的影响，而timestamp会根据时区进行转换。</li><li>datetime占用更多的存储空间，而timestamp占用更少的空间。</li><li>datetime可以使用默认值或函数来赋值，而timestamp会自动赋值为当前时间。</li></ul>`,58),i=[l];function d(r,p){return e(),a("div",null,i)}const u=t(s,[["render",d],["__file","MYSQL关键字.html.vue"]]);export{u as default};
