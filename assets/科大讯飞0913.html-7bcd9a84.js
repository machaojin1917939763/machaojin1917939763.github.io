import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,b as i}from"./app-83c3c924.js";const p={},l=i('<h2 id="普通变量和静态变量的区别" tabindex="-1"><a class="header-anchor" href="#普通变量和静态变量的区别" aria-hidden="true">#</a> 普通变量和静态变量的区别</h2><p>从使用上的区别</p><p>从存储上的区别</p><h2 id="和equals" tabindex="-1"><a class="header-anchor" href="#和equals" aria-hidden="true">#</a> ==和equals</h2><h2 id="int和integer区别" tabindex="-1"><a class="header-anchor" href="#int和integer区别" aria-hidden="true">#</a> int和Integer区别</h2><p>形式上面</p><p>内存构成</p><p>各自的特性</p><p>自动拆箱和装箱</p><h2 id="接口和抽象类区别" tabindex="-1"><a class="header-anchor" href="#接口和抽象类区别" aria-hidden="true">#</a> 接口和抽象类区别</h2><p>构造方法</p><p>关键字</p><p>多继承和单继承</p><p>变量</p><p>默认权限修饰符</p><h2 id="接口默认方法" tabindex="-1"><a class="header-anchor" href="#接口默认方法" aria-hidden="true">#</a> 接口默认方法</h2><p>default，可实现方法体</p><h2 id="synchronized和reentrantlock" tabindex="-1"><a class="header-anchor" href="#synchronized和reentrantlock" aria-hidden="true">#</a> Synchronized和Reentrantlock</h2><p>实现的层级，一个是基于JVM一个是基于jdk</p><p>锁升级</p><p>公平锁和非公平锁</p><p>都是可重入的锁</p><p>一个不可打断，一个可打断</p><h2 id="synchronized锁升级" tabindex="-1"><a class="header-anchor" href="#synchronized锁升级" aria-hidden="true">#</a> Synchronized锁升级</h2><p>新的对象创建出来默认是无锁</p><p>当有线程来加锁时会升级成为偏向锁</p><p>当锁加锁完毕释放完锁时，其他先来继续来抢，会升级成为轻量级锁</p><p>当有线程持有这个对象的锁时，其他线程再来的时候会升级成为重量级锁</p><h2 id="线程安全的容器" tabindex="-1"><a class="header-anchor" href="#线程安全的容器" aria-hidden="true">#</a> 线程安全的容器</h2><p>currentHashMap</p><p>vector</p><p>Hashtable</p><h2 id="列表循环时删除元素时的问题" tabindex="-1"><a class="header-anchor" href="#列表循环时删除元素时的问题" aria-hidden="true">#</a> 列表循环时删除元素时的问题</h2><p>快速失败</p><p>使用迭代器可以</p><h2 id="jvm内存模型" tabindex="-1"><a class="header-anchor" href="#jvm内存模型" aria-hidden="true">#</a> JVM内存模型</h2><p>堆</p><p>栈</p><p>方法区</p><p>本地方法栈</p><p>虚拟机栈</p><h2 id="gc-垃圾回收算法-垃圾收集器" tabindex="-1"><a class="header-anchor" href="#gc-垃圾回收算法-垃圾收集器" aria-hidden="true">#</a> GC-垃圾回收算法，垃圾收集器</h2><p>标记复制</p><p>标记清除</p><p>标记整理</p><p>分代回收</p><p>Serial</p><p>Parallel Scavenge 复制算法</p><p>Parallel Old 标记整理</p><p>G1</p><p>CMS</p><p>ZGC</p><p>Parallel New</p><p>Serial Old</p><h2 id="常用的设计模式-各自的应用场景-设计思想" tabindex="-1"><a class="header-anchor" href="#常用的设计模式-各自的应用场景-设计思想" aria-hidden="true">#</a> 常用的设计模式，各自的应用场景，设计思想</h2><p>单例模式</p><p>动态代理</p><p>工厂模式</p><p>策略模式</p><p>模板方法</p><p>享元模式</p><h2 id="饿汉模式和懒汉模式" tabindex="-1"><a class="header-anchor" href="#饿汉模式和懒汉模式" aria-hidden="true">#</a> 饿汉模式和懒汉模式</h2><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><h2 id="拆包粘包" tabindex="-1"><a class="header-anchor" href="#拆包粘包" aria-hidden="true">#</a> 拆包粘包</h2><p>TCP（传输控制协议）是一个面向连接的、可靠的、字节流的传输层通信协议。在使用TCP进行数据传输时，可能会遇到所谓的“拆包”和“粘包”问题。这两个问题主要是由于TCP的流式传输特性和网络中的各种因素导致的。</p><ol><li><p><strong>什么是拆包和粘包？</strong></p><ul><li><strong>粘包</strong>：当发送方发送的数据小于TCP报文段的最大长度时，TCP会尝试等待一小段时间，看是否有更多的数据可以一起发送，这可能导致多个小数据包被合并为一个数据包进行发送，从而产生粘包。</li><li><strong>拆包</strong>：当发送方发送的数据大于TCP报文段的最大长度时，TCP会将这个数据分割成多个报文段进行发送，从而产生拆包。</li></ul></li><li><p><strong>为什么会出现拆包和粘包？</strong></p><ul><li>TCP为了高效利用网络资源，会根据网络状况进行动态的MSS（最大段大小）调整，可能会合并多个小数据包或拆分大数据包。</li><li>TCP是一个字节流协议，没有固定的边界。接收方只是简单地从接收缓冲区中读取数据，而不知道每次读取的数据是一个包还是多个包。</li><li>网络中的延迟、拥塞等因素也可能导致数据的拆分或合并。</li></ul></li><li><p><strong>如何解决拆包和粘包问题？</strong></p><ul><li><strong>消息边界</strong>：为每个消息定义一个边界，例如使用特殊的分隔符。</li><li><strong>固定长度</strong>：每个消息发送固定长度的数据，不足的部分可以用空格或其他字符填充。</li><li><strong>长度前缀</strong>：每个消息前面加上一个长度字段，表示后面数据的长度。</li><li><strong>使用应用层协议</strong>：例如HTTP、WebSocket等协议，它们在应用层已经定义了消息的边界。</li></ul></li></ol><p>总之，拆包和粘包是由于TCP的设计和网络特性导致的，需要在应用层进行处理。</p><h2 id="websocket协议设计过程" tabindex="-1"><a class="header-anchor" href="#websocket协议设计过程" aria-hidden="true">#</a> websocket协议设计过程</h2><p>WebSocket是一个为网页应用程序提供全双工通信通道的协议。它设计的初衷是为了解决HTTP协议在某些实时应用场景中的局限性，如轮询和长轮询。WebSocket提供了一个持久的、低延迟的连接，使得服务器可以主动向客户端发送数据。</p><p>WebSocket的设计过程可以从以下几个方面来理解：</p><ol><li><p><strong>需求分析</strong>：</p><ul><li>实时性：为了满足聊天应用、股票交易、在线游戏等实时应用的需求，需要一个低延迟的通信协议。</li><li>减少开销：HTTP的轮询和长轮询方式会产生大量的不必要的HTTP头部开销和连接建立/断开的开销。</li><li>全双工：允许服务器和客户端同时发送和接收数据。</li></ul></li><li><p><strong>基于已有的技术</strong>：</p><ul><li>WebSocket的握手过程基于HTTP，这使得它能够复用现有的HTTP端口（如80和443）和基础设施。</li><li>一旦握手完成，连接就升级为WebSocket连接，数据传输方式与HTTP完全不同。</li></ul></li><li><p><strong>设计细节</strong>：</p><ul><li><strong>握手</strong>：WebSocket连接的建立始于一个HTTP请求（特别是一个Upgrade请求），这使得WebSocket能够与现有的Web基础设施兼容。</li><li><strong>数据帧</strong>：WebSocket数据被分为帧，每一帧都有一个小的头部描述数据的类型（如文本、二进制、关闭、Ping/Pong等）。</li><li><strong>掩码</strong>：客户端发送到服务器的所有数据帧都必须被掩码，以增加安全性。</li><li><strong>关闭连接</strong>：WebSocket定义了一个优雅的关闭过程，允许双方交换关闭帧。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>WebSocket也有一个安全版本，称为WSS，它在TLS之上运行，提供了加密和安全的数据传输。</li><li>考虑跨站请求伪造（CSRF）和跨站脚本攻击（XSS）的风险，WebSocket握手包含了一个<code>Origin</code>头部，使得服务器可以决定是否接受来自某个源的连接。</li></ul></li><li><p><strong>与现有技术的集成</strong>：</p><ul><li>WebSocket被设计为与HTTP协议共存，这意味着它可以使用现有的Web服务器、代理和防火墙。</li></ul></li><li><p><strong>标准化</strong>：</p><ul><li>WebSocket协议由IETF的RFC 6455定义。</li><li>WebSocket API则由W3C定义，使得Web开发者可以在浏览器中使用WebSocket。</li></ul></li></ol><p>总的来说，WebSocket的设计过程是一个综合考虑实时性需求、安全性、与现有技术的兼容性和易用性的过程。</p><h2 id="说项目" tabindex="-1"><a class="header-anchor" href="#说项目" aria-hidden="true">#</a> 说项目</h2>',73),n=[l];function t(h,o){return a(),r("div",null,n)}const c=e(p,[["render",t],["__file","科大讯飞0913.html.vue"]]);export{c as default};
