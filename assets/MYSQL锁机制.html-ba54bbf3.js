import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,b as a}from"./app-48a9300c.js";const s={},d=a('<h2 id="说一下-mysql-的事务-acid-特性" tabindex="-1"><a class="header-anchor" href="#说一下-mysql-的事务-acid-特性" aria-hidden="true">#</a> 说一下 MySQL 的事务（ACID 特性）</h2><h3 id="mysql-的事务-acid-特性" tabindex="-1"><a class="header-anchor" href="#mysql-的事务-acid-特性" aria-hidden="true">#</a> MySQL 的事务（ACID 特性）</h3><p>MySQL 的事务是一系列的操作，要么全部执行，要么全部不执行，确保数据的完整性和一致性。事务的核心是 ACID 特性，以下是详细解释：</p><ol><li><p><strong>原子性 (Atomicity)</strong></p><ul><li>原子性确保事务作为一个单独的单位被执行。也就是说，要么全部操作执行，要么全部操作都不执行。</li><li>如果事务中的某个操作失败，整个事务都会失败，并将其所做的所有更改回滚到之前的状态。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`原子性`</span>是确保事务完整性的关键。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>一致性 (Consistency)</strong></p><ul><li>一致性确保事务将数据库从一个状态转移到另一个状态。在事务开始之前和事务结束之后，数据库的完整性约束必须保持不变。</li><li>例如，如果一个操作试图将一个负值插入到一个不允许负值的列中，整个事务都会被回滚。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`一致性`</span>确保数据库的状态始终保持一致。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>隔离性 (Isolation)</strong></p><ul><li>隔离性确保并发执行的事务不会互相影响。每个事务都在一个独立的“沙盒”中操作，这意味着所有的操作都是在一个临时的世界中执行的，除非事务被提交。</li><li>这可以防止数据损坏，因为每个事务都不会看到其他事务的中间状态。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`隔离性`</span>确保每个事务都在其自己的私有环境中运行。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>持久性 (Durability)</strong></p><ul><li>持久性确保一旦事务被提交，其所做的更改就会永久保存在数据库中。即使发生系统崩溃，更改也不会丢失。</li><li>这通常是通过将事务日志写入磁盘来实现的。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`持久性`</span>确保事务的结果永久地保存在数据库中。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>ACID 特性确保数据库事务的可靠性和完整性。</p></div><h2 id="mysql-具体有哪些锁、粒度和开销" tabindex="-1"><a class="header-anchor" href="#mysql-具体有哪些锁、粒度和开销" aria-hidden="true">#</a> MySQL 具体有哪些锁、粒度和开销</h2><h3 id="mysql-的锁、粒度和开销" tabindex="-1"><a class="header-anchor" href="#mysql-的锁、粒度和开销" aria-hidden="true">#</a> MySQL 的锁、粒度和开销</h3><p>MySQL 提供了多种锁策略，以支持不同的使用场景。以下是 MySQL 中的锁、其粒度和相关开销的概述：</p><ol><li><p><strong>全局锁 (Global Locks)</strong></p><ul><li><strong>粒度</strong>: 最粗的锁粒度，涉及整个数据库。</li><li><strong>开销</strong>: 非常高，因为它会阻止所有其他操作。</li><li><strong>应用</strong>: 例如，当执行<code>FLUSH TABLES WITH READ LOCK</code>命令备份数据库时。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`全局锁`</span>会锁定整个数据库。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>表锁 (Table Locks)</strong></p><ul><li><strong>粒度</strong>: 表级别。</li><li><strong>开销</strong>: 较高，因为它会锁定整个表，其他线程不能对其进行写操作。</li><li><strong>应用</strong>: MyISAM 存储引擎使用表锁。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`表锁`</span>会锁定整个表。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>行锁 (Row Locks)</strong></p><ul><li><strong>粒度</strong>: 行级别。</li><li><strong>开销</strong>: 相对较低，因为它只锁定特定的行。</li><li><strong>应用</strong>: InnoDB 存储引擎使用行锁。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`行锁`</span>锁定特定的数据行。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>意向锁 (Intention Locks)</strong></p><ul><li><strong>粒度</strong>: 表级别。</li><li><strong>开销</strong>: 中等。</li><li><strong>应用</strong>: InnoDB 使用意向锁来表明它想要在更细的粒度上获得锁，例如行锁。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`意向锁`</span>是一个预先声明的锁，表示将来可能会锁定某个资源。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>记录锁 (Record Locks)</strong></p><ul><li><strong>粒度</strong>: 单个行记录。</li><li><strong>开销</strong>: 与行锁相似。</li><li><strong>应用</strong>: InnoDB 对单个行记录进行锁定。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`记录锁`</span>锁定单个行记录。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>间隙锁 (Gap Locks)</strong></p><ul><li><strong>粒度</strong>: 两个索引之间的间隙。</li><li><strong>开销</strong>: 中等。</li><li><strong>应用</strong>: InnoDB 使用间隙锁来防止记录在两个索引之间插入。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`间隙锁`</span>锁定索引之间的间隙。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>临键锁 (Next-Key Locks)</strong></p><ul><li><strong>粒度</strong>: 行记录和其前面的间隙。</li><li><strong>开销</strong>: 中等。</li><li><strong>应用</strong>: InnoDB 使用临键锁，它是记录锁和间隙锁的组合。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`临键锁`</span>锁定行记录及其前面的间隙。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>不同的锁策略和粒度对性能和并发性有不同的影响。选择正确的锁策略是确保高性能和数据完整性的关键。</p></div><h2 id="innodb-有哪几种行锁" tabindex="-1"><a class="header-anchor" href="#innodb-有哪几种行锁" aria-hidden="true">#</a> InnoDB 有哪几种行锁？</h2><h3 id="innodb-的行锁" tabindex="-1"><a class="header-anchor" href="#innodb-的行锁" aria-hidden="true">#</a> InnoDB 的行锁</h3><p>InnoDB 存储引擎为了实现高并发和数据一致性，提供了几种行锁。以下是 InnoDB 中的行锁类型：</p><ol><li><p><strong>记录锁 (Record Locks)</strong></p><ul><li>锁定一个具体的行记录。</li><li>当对一个行记录进行读取或修改操作时，InnoDB 会使用记录锁来锁定该行。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`记录锁`</span>锁定特定的行记录。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>间隙锁 (Gap Locks)</strong></p><ul><li>锁定一个索引之间的间隙，但不包括记录本身。</li><li>这种锁主要用于防止其他事务在这个间隙中插入新的记录。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`间隙锁`</span>锁定索引之间的间隙，但不包括记录本身。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>临键锁 (Next-Key Locks)</strong></p><ul><li>是记录锁和间隙锁的组合。</li><li>锁定一个记录以及该记录之前的间隙。</li><li>这种锁策略可以确保范围查询的一致性。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`临键锁`</span>锁定行记录及其前面的间隙。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>插入意向锁 (Insert Intention Locks)</strong></p><ul><li>是一种特殊类型的间隙锁，用于表明事务打算在某个间隙中插入一个新的记录。</li><li>当多个事务都想在同一个间隙中插入记录时，插入意向锁可以确保这些事务按顺序执行。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`插入意向锁`</span>表示事务打算在某个间隙中插入新记录。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>InnoDB 的行锁策略旨在实现高并发操作，同时确保数据的一致性和完整性。</p></div><h2 id="innodb-行锁的内部实现原理是什么" tabindex="-1"><a class="header-anchor" href="#innodb-行锁的内部实现原理是什么" aria-hidden="true">#</a> InnoDB 行锁的内部实现原理是什么</h2><h3 id="innodb-行锁的内部实现原理" tabindex="-1"><a class="header-anchor" href="#innodb-行锁的内部实现原理" aria-hidden="true">#</a> InnoDB 行锁的内部实现原理</h3><p>InnoDB 的行锁实现是基于其索引组织的方式。以下是其内部实现原理的详细描述：</p><ol><li><p><strong>基于索引的锁定</strong></p><ul><li>InnoDB 的行锁是基于索引的，无论是主键索引还是辅助索引。如果在没有索引的列上执行锁定操作，InnoDB 会使用隐藏的聚簇索引。</li><li>这意味着，为了获得最佳的锁定性能，查询应该使用索引。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`基于索引的锁定`</span>意味着所有的行锁操作都与某个索引关联。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>锁定队列</strong></p><ul><li>当一个事务试图锁定一个已经被另一个事务锁定的记录时，它会进入一个锁定队列，等待前一个事务释放锁。</li><li>InnoDB 使用死锁检测算法来检查和解决可能的死锁情况。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`锁定队列`</span>确保事务按照它们请求锁的顺序获得锁。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>多粒度锁定</strong></p><ul><li>InnoDB 支持多种锁定粒度，包括行锁、间隙锁和表锁。这允许它在不同的情况下选择最合适的锁定策略。</li><li>例如，对于大范围的查询，InnoDB 可能会选择使用表锁而不是行锁。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`多粒度锁定`</span>允许 InnoDB 根据操作的性质选择最佳的锁定策略。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>意向锁</strong></p><ul><li>InnoDB 使用意向锁来表明一个事务希望获得一个更细粒度的锁。这是一个优化机制，用于减少锁定冲突的可能性。</li><li>意向锁是表级别的，它们表明事务打算在表的某个部分上获得行锁。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`意向锁`</span>是一个优化机制，用于减少锁定冲突。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>记录、间隙和临键锁</strong></p><ul><li>InnoDB 使用记录锁来锁定单个行记录，使用间隙锁来锁定索引之间的间隙，使用临键锁来锁定记录和其前面的间隙。</li><li>这些锁策略允许 InnoDB 在保持数据一致性的同时，实现高并发性。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`记录、间隙和临键锁`</span>是 InnoDB 的核心锁定策略，用于实现高并发性和数据一致性。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>InnoDB 的行锁实现是为了支持高并发操作，同时确保数据的完整性和一致性。</p></div><h2 id="锁是如何加载索引上的" tabindex="-1"><a class="header-anchor" href="#锁是如何加载索引上的" aria-hidden="true">#</a> 锁是如何加载索引上的？</h2><h3 id="锁在索引上的加载方式" tabindex="-1"><a class="header-anchor" href="#锁在索引上的加载方式" aria-hidden="true">#</a> 锁在索引上的加载方式</h3><p>InnoDB 的行锁是基于索引的，这意味着锁定机制与索引结构紧密相关。以下是锁如何加载到索引上的详细描述：</p><ol><li><p><strong>B+树索引结构</strong></p><ul><li>InnoDB 使用 B+树作为其索引结构，无论是聚簇索引（主键索引）还是非聚簇索引（辅助索引）。</li><li>锁定操作主要在这些 B+树的叶子节点上执行，因为叶子节点包含了实际的数据或指向聚簇索引的指针。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`B+树索引结构`</span>是 InnoDB 锁定机制的基础。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>记录锁</strong></p><ul><li>当执行一个锁定操作时，InnoDB 会在 B+树索引的相应叶子节点上设置记录锁。</li><li>如果查询使用了索引，那么锁会直接应用到索引项上。如果没有使用索引，InnoDB 会回退到聚簇索引（隐藏的主键）。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`记录锁`</span>直接锁定 B+树索引的叶子节点。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>间隙锁</strong></p><ul><li>间隙锁不是锁定实际的索引记录，而是锁定两个索引记录之间的间隙。</li><li>这种锁确保在锁定期间，没有新的记录可以插入到这个间隙中。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`间隙锁`</span>锁定索引记录之间的空隙。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>临键锁</strong></p><ul><li>临键锁是记录锁和间隙锁的组合。</li><li>当一个事务锁定一个记录时，它同时锁定该记录和前面的间隙，确保范围查询的一致性。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`临键锁`</span>锁定索引记录及其前面的间隙。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>锁的传播</strong></p><ul><li>当使用非聚簇索引（辅助索引）进行查询并需要锁定时，InnoDB 首先在非聚簇索引上设置锁，然后再在聚簇索引上设置锁。</li><li>这是因为非聚簇索引的叶子节点包含指向聚簇索引的指针。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`锁的传播`</span>从非聚簇索引传递到聚簇索引。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>锁在索引上的加载方式是为了确保数据的一致性和完整性，同时支持高并发操作。</p></div><h2 id="如果一张表有五个索引-一个加锁语句进来-会不会同时对五个索引加锁" tabindex="-1"><a class="header-anchor" href="#如果一张表有五个索引-一个加锁语句进来-会不会同时对五个索引加锁" aria-hidden="true">#</a> 如果一张表有五个索引，一个加锁语句进来，会不会同时对五个索引加锁？</h2><h3 id="对多索引表的锁定行为" tabindex="-1"><a class="header-anchor" href="#对多索引表的锁定行为" aria-hidden="true">#</a> 对多索引表的锁定行为</h3><p>当一张表有多个索引时，一个加锁语句（例如<code>SELECT ... FOR UPDATE</code>）进来，它不会对所有的索引都加锁。锁的行为取决于查询使用的索引。以下是详细的解释：</p><ol><li><p><strong>使用的索引</strong></p><ul><li>当执行一个加锁语句时，InnoDB 会根据查询使用的索引来决定锁定哪个索引。</li><li>例如，如果你的查询是基于某个特定的索引进行的，那么只有这个索引会被锁定。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`使用的索引`</span>决定了锁定哪个索引。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>聚簇索引 (主键索引)</strong></p><ul><li>无论查询使用哪个非聚簇索引（辅助索引），最终的锁定操作都会传播到聚簇索引，因为实际的数据行存储在聚簇索引中。</li><li>所以，即使你的查询是基于非聚簇索引的，聚簇索引上的相应行也会被锁定。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`聚簇索引`</span>总是涉及锁定，因为它包含实际的数据行。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>锁的粒度</strong></p><ul><li>即使查询使用了某个索引，这并不意味着整个索引都会被锁定。锁的粒度通常是行级的，这意味着只有查询涉及的行会被锁定。</li></ul><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token code-snippet code keyword">`锁的粒度`</span>通常是行级的，不是整个索引。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>简而言之，一个加锁语句不会对表中的所有索引都加锁，只会锁定查询实际使用或涉及的索引上的特定行。</p></div>',30),l=[d];function o(r,c){return e(),i("div",null,l)}const u=n(s,[["render",o],["__file","MYSQL锁机制.html.vue"]]);export{u as default};
