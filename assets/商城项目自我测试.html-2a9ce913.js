import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,b as t}from"./app-7c2bb0f2.js";const e={},o=t(`<p>有关项目可能被问到的问题（8月22日需要弄清楚的）</p><h2 id="_1、项目的难点在哪-你是如何解决的" tabindex="-1"><a class="header-anchor" href="#_1、项目的难点在哪-你是如何解决的" aria-hidden="true">#</a> 1、项目的难点在哪，你是如何解决的？</h2><h2 id="_2、怎么想的-为什么要做这个项目" tabindex="-1"><a class="header-anchor" href="#_2、怎么想的-为什么要做这个项目" aria-hidden="true">#</a> 2、怎么想的，为什么要做这个项目？</h2><h2 id="_3、技术是怎么选型的-怎么落地的" tabindex="-1"><a class="header-anchor" href="#_3、技术是怎么选型的-怎么落地的" aria-hidden="true">#</a> 3、技术是怎么选型的，怎么落地的？</h2><h2 id="_4、用到了哪些技术-为什么要用这些技术" tabindex="-1"><a class="header-anchor" href="#_4、用到了哪些技术-为什么要用这些技术" aria-hidden="true">#</a> 4、用到了哪些技术？为什么要用这些技术？</h2><ol><li><p><strong>Java</strong>:</p><ul><li><strong>为什么</strong>：Java 是一个成熟、稳定且广泛使用的编程语言。它的跨平台能力、强大的标准库和丰富的开源生态系统使其成为企业级应用的首选。</li><li><strong>在项目中的应用</strong>：Java 作为主要的后端开发语言，处理业务逻辑、数据处理等。</li></ul></li><li><p><strong>Spring Boot &amp; Spring Cloud (微服务)</strong>:</p><ul><li><strong>为什么</strong>：Spring Boot 提供了快速开发、自动配置和生产级别的运行时。Spring Cloud 提供了一套微服务解决方案，包括服务发现、配置中心、负载均衡等。</li><li><strong>在项目中的应用</strong>：项目采用微服务架构，每个功能模块作为一个独立的服务运行。Spring Cloud 提供了服务之间的通信、配置管理等功能。</li></ul></li><li><p><strong>MyBatis</strong>:</p><ul><li><strong>为什么</strong>：MyBatis 提供了灵活的 SQL 查询和结果映射，与 JDBC 相比，它大大简化了数据库操作代码。</li><li><strong>在项目中的应用</strong>：用于与 MySQL 数据库进行交互，处理数据的查询、插入、更新和删除。</li></ul></li><li><p><strong>MySQL</strong>:</p><ul><li><strong>为什么</strong>：MySQL 是一个开源、高性能、稳定的关系型数据库，适合存储结构化数据。</li><li><strong>在项目中的应用</strong>：存储项目的主要数据，如用户信息、订单、商品等。</li></ul></li><li><p><strong>Redis</strong>:</p><ul><li><strong>为什么</strong>：Redis 提供了超高速的数据访问速度，适合作为缓存、会话存储或轻量级的消息队列。</li><li><strong>在项目中的应用</strong>：用于缓存频繁访问的数据，如购物车信息、用户会话等。</li></ul></li><li><p><strong>Docker</strong>:</p><ul><li><strong>为什么</strong>：Docker 提供了容器化的解决方案，确保应用在不同环境中的一致性。</li><li><strong>在项目中的应用</strong>：用于打包、部署和运行微服务。</li></ul></li><li><p><strong>Vue.js</strong>:</p><ul><li><strong>为什么</strong>：Vue.js 是一个轻量级、易于上手且功能强大的前端框架。</li><li><strong>在项目中的应用</strong>：构建项目的前端界面，与后端微服务交互。</li></ul></li><li><p><strong>Nginx</strong>:</p><ul><li><strong>为什么</strong>：Nginx 是一个高性能的 web 服务器，也可以作为反向代理、负载均衡器。</li><li><strong>在项目中的应用</strong>：处理客户端的请求，将其转发到相应的微服务。</li></ul></li><li><p><strong>RabbitMQ (消息队列)</strong>:</p><ul><li><strong>为什么</strong>：在微服务架构中，服务之间的直接调用可能会导致耦合度增加。消息队列提供了一种异步通信方式，解耦服务之间的依赖。</li><li><strong>在项目中的应用</strong>：处理服务之间的异步通信，如订单创建、库存更新等。</li></ul></li><li><p><strong>Elasticsearch (搜索引擎)</strong>:</p><ul><li><strong>为什么</strong>：提供了快速的文本搜索和数据分析能力。</li><li><strong>在项目中的应用</strong>：用于商品搜索、日志分析等。</li></ul></li></ol><p>选择这些技术的原因是基于它们的性能、稳定性、社区支持以及与其他技术的集成能力。微服务架构使得每个服务可以独立开发、部署和扩展，提高了系统的可维护性和可扩展性。</p><h2 id="_5、画出商品的构造图" tabindex="-1"><a class="header-anchor" href="#_5、画出商品的构造图" aria-hidden="true">#</a> 5、画出商品的构造图？</h2><h2 id="_6、相比于其他的同类项目-你的项目有什么优势" tabindex="-1"><a class="header-anchor" href="#_6、相比于其他的同类项目-你的项目有什么优势" aria-hidden="true">#</a> 6、相比于其他的同类项目，你的项目有什么优势？</h2><p>这个项目是一个致力于打造完整的大型分布式架构电商平台的项目。从项目的描述和技术选型中，我们可以识别出以下优势：</p><ol><li><strong>完整的电商功能</strong>：项目不仅包括前台的商城系统（如用户登录、注册、商品搜索、商品详情、购物车、订单、秒杀活动等），还包括后台的管理系统（如系统管理、商品系统、优惠营销、库存系统、订单系统、用户系统、内容管理等）。</li><li><strong>现代技术栈</strong>：项目采用了当前流行的技术，如 SpringCloud、SpringCloud Alibaba、MyBatis Plus、Elasticsearch、RabbitMQ、Redis、Docker 等，这些技术都是当前企业级应用中的热门选择。</li><li><strong>微服务架构</strong>：项目基于 SpringCloud 和 SpringCloud Alibaba 实现微服务架构，这意味着每个功能模块都作为一个独立的服务运行，这样的架构可以提高系统的可扩展性和可维护性。</li><li><strong>前后端分离</strong>：项目采用前后端分离的方式编写，这样可以使前端和后端独立开发和部署，提高开发效率。</li><li><strong>代码生成器</strong>：项目中包含了人人开源项目的代码生成器，这可以大大加速开发速度，减少重复代码的编写。</li><li><strong>容器化部署</strong>：项目支持 Docker，这意味着可以确保应用在不同环境中的一致性，并简化部署和扩展的过程。</li><li><strong>高性能和高可用性</strong>：通过使用 Nginx、Redis、RabbitMQ、Elasticsearch 等技术，项目可以实现高性能、高可用性和高并发。</li></ol><p>相比于其他同类项目，谷粒商城的优势在于其完整的功能、现代的技术栈、微服务架构、前后端分离的设计、丰富的学习资源和容器化部署。这些特点使其成为一个非常适合学习和实践的项目。</p><h2 id="_7、介绍一下你的项目" tabindex="-1"><a class="header-anchor" href="#_7、介绍一下你的项目" aria-hidden="true">#</a> 7、介绍一下你的项目</h2><h2 id="_8、商品表是怎么设计的-有哪些字段" tabindex="-1"><a class="header-anchor" href="#_8、商品表是怎么设计的-有哪些字段" aria-hidden="true">#</a> 8、商品表是怎么设计的？有哪些字段？</h2><h2 id="_9、分类表是如何设计的" tabindex="-1"><a class="header-anchor" href="#_9、分类表是如何设计的" aria-hidden="true">#</a> 9、分类表是如何设计的？</h2><h2 id="_10、品牌表是怎么设计的" tabindex="-1"><a class="header-anchor" href="#_10、品牌表是怎么设计的" aria-hidden="true">#</a> 10、品牌表是怎么设计的？</h2><h2 id="_11、什么是spu和sku-他们之间的关系是什么" tabindex="-1"><a class="header-anchor" href="#_11、什么是spu和sku-他们之间的关系是什么" aria-hidden="true">#</a> 11、什么是SPU和SKU，他们之间的关系是什么？</h2><p>SPU 和 SKU 是电商领域中常用的术语，它们分别代表了商品的两个不同层次的概念。</p><ol><li><p><strong>SPU (Standard Product Unit) - 标准化产品单位</strong>:</p><ul><li>SPU 是商品信息聚合的最小单位。它通常表示某一款商品的共同特性。</li><li>例如，一个型号的手机，不论其颜色、存储容量等都属于同一个SPU。</li></ul></li><li><p><strong>SKU (Stock Keeping Unit) - 库存量单位</strong>:</p><ul><li>SKU 是商品库存的最小单位。对于一个SPU，根据其不同的属性（如颜色、尺寸、规格等），可以有多个SKU。</li><li>例如，同一个型号的手机，根据颜色和存储容量的不同，可以有多个SKU，如“黑色、64GB”或“白色、128GB”。</li></ul></li></ol><h3 id="他们之间的关系" tabindex="-1"><a class="header-anchor" href="#他们之间的关系" aria-hidden="true">#</a> 他们之间的关系：</h3><ul><li>一个SPU下面可以有多个SKU。换句话说，SKU是SPU的细化。</li><li>SPU关注的是商品的共同特性，而SKU关注的是商品的区别特性。</li><li>在购买商品时，用户通常会选择一个具体的SKU进行购买，而不是SPU。</li></ul><p>以手机为例：</p><ul><li>SPU可能是“iPhone 12”这款手机的所有共同特性。</li><li>SKU则可能是“iPhone 12, 黑色, 64GB”或“iPhone 12, 白色, 128GB”。</li></ul><p>总之，SPU和SKU是电商领域中描述商品的两个重要概念，它们帮助商家更好地管理商品信息和库存。</p><h2 id="_12、什么是基本属性-什么是销售属性" tabindex="-1"><a class="header-anchor" href="#_12、什么是基本属性-什么是销售属性" aria-hidden="true">#</a> 12、什么是基本属性，什么是销售属性？</h2><p>在电商领域，商品属性通常被分为两类：基本属性和销售属性。这两种属性对于商品的描述和销售都起到了关键的作用。</p><ol><li><p><strong>基本属性 (也称为非销售属性)</strong>:</p><ul><li>描述商品的固有特性和基本信息。</li><li>这些属性通常对于一个商品系列或SPU是固定的，不会因为用户的选择而改变。</li><li><strong>示例</strong>：对于一款手机，其基本属性可能包括品牌、屏幕尺寸、处理器型号、摄像头像素等。</li></ul></li><li><p><strong>销售属性</strong>:</p><ul><li>描述商品的可选特性，通常会影响商品的SKU。</li><li>用户在购买商品时可以选择的属性，基于这些属性的不同组合，商品可能有不同的价格、库存等。</li><li><strong>示例</strong>：对于同一款手机，其销售属性可能包括颜色、存储容量等。不同的颜色和存储容量组合会产生不同的SKU，每个SKU可能有不同的价格和库存。</li></ul></li></ol><h3 id="它们之间的关系" tabindex="-1"><a class="header-anchor" href="#它们之间的关系" aria-hidden="true">#</a> 它们之间的关系：</h3><ul><li><strong>基本属性</strong>为用户提供了商品的基本信息和特性，帮助用户了解商品的主要功能和规格。</li><li><strong>销售属性</strong>则为用户提供了购买选择，基于这些选择，用户可以购买到满足自己需求的具体商品版本或型号。</li></ul><p>在电商平台上，基本属性和销售属性都是非常重要的。基本属性帮助用户了解商品的主要特性，而销售属性则影响用户的购买决策和购买体验。</p><h2 id="_13、怎么实现的新增商品-具体的流程画一下" tabindex="-1"><a class="header-anchor" href="#_13、怎么实现的新增商品-具体的流程画一下" aria-hidden="true">#</a> 13、怎么实现的新增商品？具体的流程画一下</h2><h2 id="_14、新增商品中调用了其他服务-那如果新增商品过程中失败了-怎么回滚" tabindex="-1"><a class="header-anchor" href="#_14、新增商品中调用了其他服务-那如果新增商品过程中失败了-怎么回滚" aria-hidden="true">#</a> 14、新增商品中调用了其他服务，那如果新增商品过程中失败了，怎么回滚？</h2><p>在微服务架构中，由于服务之间是分布式的，传统的数据库事务方法（如 RDBMS 的 ACID 事务）不再适用。当在一个微服务中的操作依赖于其他微服务的操作时，需要使用一种称为“分布式事务”的方法来确保数据的一致性。</p><p>为了处理分布式事务和确保在失败时能够回滚操作，通常采用以下策略：</p><ol><li><p><strong>Saga模式</strong>:</p><ul><li>Saga 是一种长寿命的事务，它由多个子事务组成，每个子事务都是一个独立的事务。</li><li>如果某个子事务失败，Saga 会执行相应的补偿事务来回滚之前的操作。</li><li>Saga 可以是串行的或并行的，并且可以通过事件、消息队列或其他机制来协调。</li></ul></li><li><p><strong>两阶段提交 (2PC)</strong>:</p><ul><li>这是一种经典的分布式事务协议，但由于其性能开销和其他问题，它在微服务架构中不太受欢迎。</li></ul></li><li><p><strong>TCC (Try-Confirm-Cancel)</strong>:</p><ul><li>TCC 是一种补偿型事务模式，它包括三个步骤：尝试、确认和取消。</li><li>在尝试阶段，系统预留必要的资源；在确认阶段，系统真正执行事务；如果事务失败，系统在取消阶段释放预留的资源。</li></ul></li><li><p><strong>消息驱动的事务</strong>:</p><ul><li>使用消息队列（如 RabbitMQ、Kafka）来确保数据的一致性。</li><li>如果一个服务的操作失败，它可以发送一个消息到消息队列，通知其他服务回滚其操作。</li></ul></li><li><p><strong>幂等性</strong>:</p><ul><li>确保服务的操作是幂等的，这意味着无论操作执行多少次，结果都是相同的。</li><li>这可以确保在失败和重试的情况下，数据仍然保持一致。</li></ul></li></ol><p>在实际应用中，选择哪种策略取决于具体的业务需求、系统的复杂性和其他因素。但无论选择哪种策略，都需要确保在分布式环境中数据的一致性和完整性。</p><h2 id="_15、说一下seata-什么是xc-什么是xa-有什么缺点" tabindex="-1"><a class="header-anchor" href="#_15、说一下seata-什么是xc-什么是xa-有什么缺点" aria-hidden="true">#</a> 15、说一下seata？什么是XC，什么是XA？有什么缺点？</h2><p><strong>Seata</strong>（之前称为Fescar）是一个开源的分布式事务解决方案，旨在提供高性能和简单易用的分布式事务服务。Seata 的主要目标是简化分布式事务的复杂性，使其与本地事务一样简单。</p><h3 id="seata-的核心概念" tabindex="-1"><a class="header-anchor" href="#seata-的核心概念" aria-hidden="true">#</a> Seata 的核心概念：</h3><ol><li><strong>全局事务</strong>：由一系列分支事务组成的事务。</li><li><strong>分支事务</strong>：一个全局事务中的局部事务段。</li><li><strong>TC (Transaction Coordinator)</strong>：全局事务协调者，负责全局事务的开始、提交和回滚。</li><li><strong>TM (Transaction Manager)</strong>：控制全局事务的边界，即开始或提交一个全局事务。</li><li><strong>RM (Resource Manager)</strong>：控制分支事务，负责分支事务的资源（如数据库连接）的管理。</li></ol><h3 id="xa-和-xc" tabindex="-1"><a class="header-anchor" href="#xa-和-xc" aria-hidden="true">#</a> XA 和 XC：</h3><ol><li><p><strong>XA</strong>：是一个由 X/Open 组织定义的两阶段提交协议。它是一个全球标准，用于在分布式系统中协调事务。</p><ul><li>第一阶段：所有参与者都被询问是否可以提交事务。</li><li>第二阶段：基于第一阶段的结果，协调者决定提交或回滚事务，并通知所有参与者。</li></ul></li><li><p><strong>XC</strong>：是 Seata 的自定义协议，它是基于 XA 的改进版本，但更加轻量级和高效。</p></li></ol><h3 id="seata-的缺点" tabindex="-1"><a class="header-anchor" href="#seata-的缺点" aria-hidden="true">#</a> Seata 的缺点：</h3><ol><li><strong>性能开销</strong>：虽然 Seata 旨在提供高性能的分布式事务解决方案，但与传统的单体应用事务相比，它仍然带来了额外的性能开销。</li><li><strong>复杂性</strong>：引入分布式事务会增加系统的复杂性，需要更多的配置和管理。</li><li><strong>资源锁定</strong>：在某些情况下，Seata 可能需要锁定资源，直到全局事务提交或回滚，这可能会影响系统的吞吐量。</li><li><strong>依赖外部存储</strong>：Seata 需要一个外部的存储系统（如数据库）来存储事务日志，这增加了系统的复杂性和故障点。</li></ol><p>尽管 Seata 有这些缺点，但它仍然是一个非常有用的工具，特别是对于需要确保数据一致性的分布式应用。</p><h3 id="_1-tc-transaction-coordinator-事务协调者" tabindex="-1"><a class="header-anchor" href="#_1-tc-transaction-coordinator-事务协调者" aria-hidden="true">#</a> 1. TC (Transaction Coordinator) - 事务协调者：</h3><ul><li><p><strong>职责</strong>：TC 是 Seata 的核心组件，负责协调全局事务的提交或回滚。</p></li><li><p>工作流程</p><p>：</p><ul><li>当 TM 请求开始一个新的全局事务时，TC 会生成一个全局事务ID。</li><li>当各个参与的微服务（通过 RM）报告其本地事务的状态时，TC 跟踪这些状态。</li><li>在全局事务提交时，TC 决定是否所有参与的微服务都可以提交其本地事务，或者是否需要回滚。</li></ul></li><li><p><strong>存储</strong>：TC 通常需要一个持久化存储（如数据库）来记录事务日志，以确保在系统故障时可以恢复事务状态。</p></li></ul><h3 id="_2-tm-transaction-manager-事务管理器" tabindex="-1"><a class="header-anchor" href="#_2-tm-transaction-manager-事务管理器" aria-hidden="true">#</a> 2. TM (Transaction Manager) - 事务管理器：</h3><ul><li><p><strong>职责</strong>：TM 负责定义全局事务的边界，即开始和结束一个全局事务。</p></li><li><p>工作流程</p><p>：</p><ul><li>TM 通过调用 TC 来开始一个新的全局事务，并获得一个全局事务ID。</li><li>在全局事务中，TM 可以调用多个微服务来执行业务操作。</li><li>一旦所有业务操作都完成，TM 决定提交或回滚全局事务，并通知 TC。</li></ul></li></ul><h3 id="_3-rm-resource-manager-资源管理器" tabindex="-1"><a class="header-anchor" href="#_3-rm-resource-manager-资源管理器" aria-hidden="true">#</a> 3. RM (Resource Manager) - 资源管理器：</h3><ul><li><p><strong>职责</strong>：RM 负责管理资源，如数据库连接，以及执行本地事务。</p></li><li><p>工作流程</p><p>：</p><ul><li>当一个微服务参与到全局事务中时，它的本地事务由 RM 管理。</li><li>RM 保证本地事务的成功执行，并向 TC 报告其状态。</li><li>如果 TC 决定回滚全局事务，RM 负责回滚其本地事务。</li></ul></li><li><p><strong>资源锁定</strong>：为了确保数据的一致性，RM 可能需要锁定资源，直到全局事务提交或回滚。</p></li></ul><p>Seata 和 Saga 模式以及消息型事务都是解决分布式事务问题的策略，但它们的工作方式和应用场景有所不同。以下是它们之间的主要区别：</p><h3 id="_1-seata" tabindex="-1"><a class="header-anchor" href="#_1-seata" aria-hidden="true">#</a> 1. Seata：</h3><ul><li><strong>工作方式</strong>：Seata 采用了两阶段提交的思想，但进行了优化以适应微服务环境。它包括三个主要组件：TM (Transaction Manager)、RM (Resource Manager) 和 TC (Transaction Coordinator)。</li><li><strong>特点</strong>： <ul><li>提供了 AT、TCC、XA 和 SAGA 四种模式。</li><li>AT 模式是 Seata 的默认模式，它通过拦截 SQL 语句并记录前后镜像来实现自动回滚。</li><li>TCC 模式需要用户定义 Try、Confirm 和 Cancel 三个操作。</li><li>XA 模式是传统的两阶段提交。</li><li>SAGA 模式是基于状态机的长事务处理。</li></ul></li><li><strong>适用场景</strong>：当需要确保多个微服务间的数据一致性时。</li></ul><h3 id="_2-saga-模式" tabindex="-1"><a class="header-anchor" href="#_2-saga-模式" aria-hidden="true">#</a> 2. Saga 模式：</h3><ul><li><strong>工作方式</strong>：Saga 是一种长寿命的事务，由多个子事务组成。如果某个子事务失败，Saga 会执行相应的补偿事务来回滚之前的操作。</li><li><strong>特点</strong>： <ul><li>不是原子性的，而是确保最终一致性。</li><li>可以是串行的或并行的。</li><li>需要为每个操作定义补偿操作。</li></ul></li><li><strong>适用场景</strong>：当原子性不是首要关注点，但需要确保最终一致性时。</li></ul><h3 id="_3-消息型事务" tabindex="-1"><a class="header-anchor" href="#_3-消息型事务" aria-hidden="true">#</a> 3. 消息型事务：</h3><ul><li><strong>工作方式</strong>：使用消息队列来确保分布式事务的一致性。如果一个服务的操作失败，它可以发送一个消息到消息队列，通知其他服务回滚其操作。</li><li><strong>特点</strong>： <ul><li>基于事件驱动的架构。</li><li>需要确保消息的可靠性和消费的幂等性。</li><li>可能需要额外的机制来处理消息的重试和死信。</li></ul></li><li><strong>适用场景</strong>：当系统已经采用了事件驱动的架构，或者当需要确保跨多个服务的操作的一致性时。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结：</h3><ul><li><strong>Seata</strong> 提供了一个全面的分布式事务解决方案，支持多种模式，适合大多数场景。</li><li><strong>Saga 模式</strong> 更加灵活，但需要为每个操作定义补偿操作，适合确保最终一致性的场景。</li><li><strong>消息型事务</strong> 适合事件驱动的架构，需要确保消息的可靠性和消费的幂等性。</li></ul><p>选择哪种策略取决于具体的业务需求、系统的复杂性和其他因素。</p><h2 id="_16、什么是柔性事务" tabindex="-1"><a class="header-anchor" href="#_16、什么是柔性事务" aria-hidden="true">#</a> 16、什么是柔性事务？</h2><h2 id="_17、什么是tcc-两阶段提交是什么" tabindex="-1"><a class="header-anchor" href="#_17、什么是tcc-两阶段提交是什么" aria-hidden="true">#</a> 17、什么是TCC，两阶段提交是什么？</h2><h2 id="_18、商品是如何上架的" tabindex="-1"><a class="header-anchor" href="#_18、商品是如何上架的" aria-hidden="true">#</a> 18、商品是如何上架的？</h2><h2 id="_19、为什么要用elasticsearch作为商品的上架数据库" tabindex="-1"><a class="header-anchor" href="#_19、为什么要用elasticsearch作为商品的上架数据库" aria-hidden="true">#</a> 19、为什么要用elasticsearch作为商品的上架数据库？</h2><h2 id="_20、怎么实现的数据持久化" tabindex="-1"><a class="header-anchor" href="#_20、怎么实现的数据持久化" aria-hidden="true">#</a> 20、怎么实现的数据持久化？</h2><h2 id="_21、说一下elasticsearch的优点" tabindex="-1"><a class="header-anchor" href="#_21、说一下elasticsearch的优点" aria-hidden="true">#</a> 21、说一下elasticsearch的优点？</h2><h2 id="_22、什么是倒排索引" tabindex="-1"><a class="header-anchor" href="#_22、什么是倒排索引" aria-hidden="true">#</a> 22、什么是倒排索引？</h2><h2 id="_23、说一下添加商品所涉及到的模块" tabindex="-1"><a class="header-anchor" href="#_23、说一下添加商品所涉及到的模块" aria-hidden="true">#</a> 23、说一下添加商品所涉及到的模块？</h2><h2 id="_24、什么是oss" tabindex="-1"><a class="header-anchor" href="#_24、什么是oss" aria-hidden="true">#</a> 24、什么是OSS？</h2><h2 id="_25、openfeign如何使用" tabindex="-1"><a class="header-anchor" href="#_25、openfeign如何使用" aria-hidden="true">#</a> 25、openfeign如何使用？</h2><h2 id="_26、openfeign是http请求还是rpc请求" tabindex="-1"><a class="header-anchor" href="#_26、openfeign是http请求还是rpc请求" aria-hidden="true">#</a> 26、openfeign是http请求还是RPC请求？</h2><h2 id="_27、如果远程调用失败了如何实现快速返回" tabindex="-1"><a class="header-anchor" href="#_27、如果远程调用失败了如何实现快速返回" aria-hidden="true">#</a> 27、如果远程调用失败了如何实现快速返回？</h2><h2 id="_28、什么是服务降级-服务熔断-服务" tabindex="-1"><a class="header-anchor" href="#_28、什么是服务降级-服务熔断-服务" aria-hidden="true">#</a> 28、什么是服务降级，服务熔断，服务？？？？</h2><h2 id="_29、分类是如何实现的" tabindex="-1"><a class="header-anchor" href="#_29、分类是如何实现的" aria-hidden="true">#</a> 29、分类是如何实现的？</h2><h2 id="_30、如何实现登录" tabindex="-1"><a class="header-anchor" href="#_30、如何实现登录" aria-hidden="true">#</a> 30、如何实现登录？</h2><h2 id="_31、什么是outh2登录" tabindex="-1"><a class="header-anchor" href="#_31、什么是outh2登录" aria-hidden="true">#</a> 31、什么是outh2登录？</h2><h2 id="_32、什么时候shiro、springsecurity" tabindex="-1"><a class="header-anchor" href="#_32、什么时候shiro、springsecurity" aria-hidden="true">#</a> 32、什么时候shiro、springsecurity</h2><h2 id="_33、什么是单点登录" tabindex="-1"><a class="header-anchor" href="#_33、什么是单点登录" aria-hidden="true">#</a> 33、什么是单点登录？</h2><h2 id="_34、outh2的流程" tabindex="-1"><a class="header-anchor" href="#_34、outh2的流程" aria-hidden="true">#</a> 34、outh2的流程？</h2><h2 id="_35、能不能在用户注册的时候使用单点登录" tabindex="-1"><a class="header-anchor" href="#_35、能不能在用户注册的时候使用单点登录" aria-hidden="true">#</a> 35、能不能在用户注册的时候使用单点登录？</h2><h2 id="_36、订单详情是怎么实现的" tabindex="-1"><a class="header-anchor" href="#_36、订单详情是怎么实现的" aria-hidden="true">#</a> 36、订单详情是怎么实现的？</h2><h2 id="_37、购物车是怎么实现的-为什么要怎么设计" tabindex="-1"><a class="header-anchor" href="#_37、购物车是怎么实现的-为什么要怎么设计" aria-hidden="true">#</a> 37、购物车是怎么实现的，为什么要怎么设计？</h2><p>购物车的数据结构主要由两个类组成：<code>CartVo</code> 和 <code>CartItemVo</code>。</p><ol><li><strong>CartItemVo（购物车项）</strong>: <ul><li><code>skuId</code>: 商品的SKU ID。</li><li><code>check</code>: 商品是否被选中。</li><li><code>title</code>: 商品的标题。</li><li><code>image</code>: 商品的图片。</li><li><code>skuAttrValues</code>: 商品的套餐属性。</li><li><code>price</code>: 商品的单价。</li><li><code>count</code>: 商品的数量。</li><li><code>totalPrice</code>: 商品的总价，计算方式为单价乘以数量。</li></ul></li><li><strong>CartVo（购物车）</strong>: <ul><li><code>items</code>: 购物车中的所有商品项，是一个 <code>CartItemVo</code> 的列表。</li><li><code>countNum</code>: 购物车中的商品总数量。</li><li><code>countType</code>: 购物车中的商品种类数量。</li><li><code>totalAmount</code>: 购物车中的商品总价。</li><li><code>reduce</code>: 减免的价格。</li></ul></li></ol><p>这两个类的设计反映了购物车的基本结构：购物车由多个购物车项组成，每个购物车项代表一个商品及其相关信息。购物车还包括商品的总数量、种类数量、总价和减免价格等信息。</p><h2 id="_38、如何实现用户未登录添加购物车" tabindex="-1"><a class="header-anchor" href="#_38、如何实现用户未登录添加购物车" aria-hidden="true">#</a> 38、如何实现用户未登录添加购物车？</h2><h2 id="_39、怎么实现的商品搜索" tabindex="-1"><a class="header-anchor" href="#_39、怎么实现的商品搜索" aria-hidden="true">#</a> 39、怎么实现的商品搜索？</h2><h2 id="_40、下单流程" tabindex="-1"><a class="header-anchor" href="#_40、下单流程" aria-hidden="true">#</a> 40、下单流程?</h2><ol><li><strong>订单确认</strong> (<code>confirmOrder</code> 方法) <ul><li>获取当前登录用户的信息。</li><li>查询所有选中的购物项。</li><li>查询库存信息。</li><li>查询用户的所有收货地址。</li><li>获取用户的积分信息。</li><li>获取优惠券</li><li>生成一个防重令牌，并将其存储在Redis中，用于后续的订单提交验证。</li></ul></li><li><strong>订单提交</strong> (<code>submitOrder</code> 方法) <ul><li>验证防重令牌：确保订单不会被重复提交。</li><li>创建订单和订单项。</li><li>验证价格：确保订单的总价与用户提交的价格匹配。</li><li>保存订单。</li><li>锁定库存：确保商品有足够的库存。</li><li>如果库存锁定成功，将订单信息发送到RabbitMQ的订单延迟队列，用于后续的订单超时检查。</li><li>清除购物车中已下单的商品。</li></ul></li><li><strong>订单支付</strong> (<code>getOrderPay</code> 方法) <ul><li>根据订单号查询订单信息。</li><li>获取订单的支付信息，如订单总价、订单商品名称等。</li></ul></li><li><strong>处理支付结果</strong> (<code>handlerPayResult</code> 方法) <ul><li>保存支付的交易流水信息。</li><li>根据支付结果更新订单状态。</li></ul></li><li><strong>关闭过期订单</strong> (<code>closeOrder</code> 方法) <ul><li>查询订单的最新状态。</li><li>如果订单仍然是新创建状态并且超时未支付，则关闭订单。</li><li>关闭订单后，发送消息到RabbitMQ，通知其他服务进行关单相关的操作，如解锁库存。</li></ul></li></ol><p>此外，还有一些辅助方法，如创建订单、构建订单项、计算价格等。</p><h2 id="_41、如何实现接口幂等性" tabindex="-1"><a class="header-anchor" href="#_41、如何实现接口幂等性" aria-hidden="true">#</a> 41、如何实现接口幂等性？</h2><p>接口幂等性是确保一个接口被多次调用时，其效果与被调用一次时的效果相同，不会产生不良影响。实现接口幂等性的方法有很多，以下是一些常见的方法：</p><ol><li><strong>使用唯一标识符</strong>：为每个请求分配一个唯一的ID。在处理请求之前，检查该ID是否已经被处理过。如果已经处理过，那么直接返回之前的结果，否则继续处理请求。</li><li><strong>乐观锁</strong>：在数据库中使用版本号或时间戳字段。当更新数据时，检查版本号或时间戳是否与数据库中的值匹配。如果匹配，执行更新并增加版本号或更新时间戳。如果不匹配，说明数据已经被其他请求修改过，因此拒绝请求。</li><li><strong>分布式锁</strong>：在分布式系统中，可以使用分布式锁来确保同一时间只有一个请求能够执行。例如，可以使用Redis或Zookeeper来实现分布式锁。</li><li><strong>Token机制</strong>：为每个请求生成一个Token。客户端在发送请求时携带这个Token。服务器在接收到请求后，检查Token是否有效。如果有效，处理请求并使Token失效。如果Token已经失效，说明请求已经被处理过，直接返回之前的结果。</li><li><strong>预检请求</strong>：在处理请求之前，先发送一个预检请求来检查是否可以执行真正的请求。只有在预检请求成功后，才发送真正的请求。</li><li><strong>数据库约束</strong>：使用数据库的唯一约束或主键约束来防止重复插入数据。</li><li><strong>幂等框架</strong>：使用专门的幂等框架，如Idempotent框架，来自动处理幂等性问题。</li></ol><p>以上是一些常见的实现接口幂等性的方法。在实际应用中，可以根据具体的业务场景和需求选择合适的方法。</p><h2 id="_42、什么是防重令牌-有哪些实现" tabindex="-1"><a class="header-anchor" href="#_42、什么是防重令牌-有哪些实现" aria-hidden="true">#</a> 42、什么是防重令牌？有哪些实现？</h2><h2 id="_43、rabbitmq没有延迟队列怎么实现的延迟队列" tabindex="-1"><a class="header-anchor" href="#_43、rabbitmq没有延迟队列怎么实现的延迟队列" aria-hidden="true">#</a> 43、RabbitMQ没有延迟队列怎么实现的延迟队列？</h2><h2 id="_44、锁定库存-下单失败怎么解锁" tabindex="-1"><a class="header-anchor" href="#_44、锁定库存-下单失败怎么解锁" aria-hidden="true">#</a> 44、锁定库存，下单失败怎么解锁？</h2><h2 id="_45、超时取消订单的视线" tabindex="-1"><a class="header-anchor" href="#_45、超时取消订单的视线" aria-hidden="true">#</a> 45、超时取消订单的视线？</h2><h2 id="_46、如果我这次订单提交失败了-但是页面还没交跳转-但是防冲令牌失效了-怎么处理" tabindex="-1"><a class="header-anchor" href="#_46、如果我这次订单提交失败了-但是页面还没交跳转-但是防冲令牌失效了-怎么处理" aria-hidden="true">#</a> 46、如果我这次订单提交失败了，但是页面还没交跳转，但是防冲令牌失效了，怎么处理？</h2><h2 id="_47、临时购物车和用户登录时的购物车是怎么实现的" tabindex="-1"><a class="header-anchor" href="#_47、临时购物车和用户登录时的购物车是怎么实现的" aria-hidden="true">#</a> 47、临时购物车和用户登录时的购物车是怎么实现的？</h2><p>购物车的实现考虑了用户的登录状态，具体实现如下：</p><ol><li><strong>购物车拦截器（CartInterceptor）</strong>: <ul><li>在每次请求前，拦截器会检查用户是否已登录。</li><li>如果用户已登录，会从会话中获取用户的信息，并设置到 <code>UserInfoTo</code> 对象中。</li><li>如果用户未登录，会检查请求中是否有一个名为 <code>user-key</code> 的cookie。这个 <code>user-key</code> 是用来标识临时用户的。</li><li>如果没有 <code>user-key</code>，会为用户生成一个，并设置到 <code>UserInfoTo</code> 对象中。</li><li>在请求处理完后，如果用户是临时用户，会将 <code>user-key</code> 设置到cookie中。</li></ul></li><li><strong>购物车服务实现（CartServiceImpl）</strong>: <ul><li>服务中有一个 <code>getCart</code> 方法，用于获取购物车的内容。</li><li>如果用户未登录，直接使用 <code>user-key</code> 从Redis中获取临时购物车的内容。</li><li>如果用户已登录，会先获取用户的购物车内容，然后检查是否有临时购物车。如果有，会将临时购物车的内容合并到用户的购物车中，并更新到Redis。</li><li>合并完成后，会删除临时购物车的数据。</li></ul></li><li><strong>用户信息传递对象（UserInfoTo）</strong>: <ul><li>这是一个简单的数据对象，用于在拦截器和服务之间传递用户信息。</li><li>包含用户ID、<code>user-key</code> 和一个标志，表示用户是否是临时用户。</li></ul></li></ol><p>总的来说，当用户未登录时，系统会为其创建一个临时的购物车，并使用一个特定的 <code>user-key</code> 来标识。当用户登录后，系统会检查是否有临时购物车，如果有，会将其内容合并到用户的购物车中，并删除临时购物车。这种设计允许未登录的用户也可以使用购物车功能，而在登录后，他们之前添加到购物车的商品不会丢失。</p><h2 id="_48、临时购物车在redis中的数据结构是什么-是使用什么进行存储的" tabindex="-1"><a class="header-anchor" href="#_48、临时购物车在redis中的数据结构是什么-是使用什么进行存储的" aria-hidden="true">#</a> 48、临时购物车在redis中的数据结构是什么？是使用什么进行存储的？</h2><p>临时购物车和登录用户的购物车都是存储在Redis中的。具体的数据结构和存储方式如下：</p><ol><li><strong>数据结构</strong>: <ul><li>购物车数据在Redis中是以哈希结构存储的。每个购物车（无论是临时的还是登录用户的）都有一个唯一的key，这个key是由前缀（例如：&quot;CART_PREFIX&quot;）和用户ID或<code>user-key</code>组成的。</li><li>每个购物车项（CartItemVo）都是以其<code>skuId</code>作为哈希的字段名，而购物车项的数据（经过JSON序列化后的字符串）作为哈希的字段值。</li></ul></li><li><strong>存储方式</strong>: <ul><li>使用Spring的<code>StringRedisTemplate</code>和<code>BoundHashOperations</code>进行操作。</li><li><code>BoundHashOperations</code>是Spring Data Redis提供的一个接口，它提供了一系列方法来操作Redis的哈希结构。</li><li>在<code>CartServiceImpl</code>中，有一个<code>getCartItemOps</code>的私有方法，这个方法会根据用户的登录状态返回一个<code>BoundHashOperations</code>对象，这个对象绑定了购物车的key，可以用来操作该购物车在Redis中的数据。</li></ul></li></ol><p>具体来说，当需要添加一个商品到购物车时，会首先检查这个商品（通过<code>skuId</code>）是否已经在购物车中。如果已经存在，就更新其数量；如果不存在，就添加一个新的字段到哈希中。其他的操作，如删除商品、更改数量等，也都是基于这个哈希结构进行的。</p><p>让我们详细看一下代码：</p><ol><li><strong>购物车在Redis中的存储方式</strong>:</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">BoundHashOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCartItemOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//1判断是否已经登录</span>
    <span class="token class-name">UserInfoTo</span> userInfoTo <span class="token operator">=</span> <span class="token class-name">CartInterceptor</span><span class="token punctuation">.</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//1.1 登录使用userId操作redis</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>userInfoTo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token class-name">CartConstant</span><span class="token punctuation">.</span><span class="token constant">CART_PREFIX</span> <span class="token operator">+</span> userInfoTo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//1.2 未登录使用user-key操作redis</span>
        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token class-name">CartConstant</span><span class="token punctuation">.</span><span class="token constant">CART_PREFIX</span> <span class="token operator">+</span> userInfoTo<span class="token punctuation">.</span><span class="token function">getUserKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释:</p><ul><li>这个<code>getCartItemOps</code>方法用于获取一个<code>BoundHashOperations</code>对象，这个对象绑定了购物车的key，可以用来操作该购物车在Redis中的数据。</li><li>首先，从<code>CartInterceptor</code>的<code>threadLocal</code>中获取当前用户的信息。</li><li>如果用户已登录（即<code>userId</code>不为空），则使用<code>userId</code>作为key的一部分；否则，使用<code>user-key</code>作为key的一部分。</li><li>最后，使用<code>redisTemplate.boundHashOps</code>方法获取一个绑定了购物车key的<code>BoundHashOperations</code>对象。</li></ul><ol start="2"><li><strong>添加商品到购物车</strong>:</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">CartItemVo</span> <span class="token function">addCartItem</span><span class="token punctuation">(</span><span class="token class-name">Long</span> skuId<span class="token punctuation">,</span> <span class="token class-name">Integer</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">BoundHashOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> ops <span class="token operator">=</span> <span class="token function">getCartItemOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断当前商品是否已经存在购物车</span>
    <span class="token class-name">String</span> cartJson <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> ops<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>skuId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1 已经存在购物车，将数据取出并添加商品数量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>cartJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">CartItemVo</span> cartItemVo <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>cartJson<span class="token punctuation">,</span> <span class="token class-name">CartItemVo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cartItemVo<span class="token punctuation">.</span><span class="token function">setCount</span><span class="token punctuation">(</span>cartItemVo<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> jsonString <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>cartItemVo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ops<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>skuId<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> jsonString<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> cartItemVo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// ... [代码省略，用于处理商品不存在购物车的情况]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释:</p><ul><li>首先，使用<code>getCartItemOps</code>方法获取一个<code>BoundHashOperations</code>对象。</li><li>使用<code>ops.get</code>方法尝试从Redis中获取该商品的数据。</li><li>如果商品已经存在购物车中（即<code>cartJson</code>不为空），则解析这个JSON字符串，获取一个<code>CartItemVo</code>对象，然后增加商品的数量，并将更新后的数据存回Redis。</li><li>如果商品不存在购物车中，后面的代码（这里省略了）会处理这种情况，例如添加新的商品到购物车。</li></ul><p>通过这种方式，购物车的数据结构在Redis中是一个哈希，其中每个字段名是商品的<code>skuId</code>，字段值是商品数据的JSON字符串。这种结构使得对购物车的操作（如添加、删除商品）都非常高效。</p><h2 id="_49、购物车都是存储在redis中的吗" tabindex="-1"><a class="header-anchor" href="#_49、购物车都是存储在redis中的吗" aria-hidden="true">#</a> 49、购物车都是存储在redis中的吗？</h2><p>购物车的数据确实是存储在Redis中的。以下是<code>CartServiceImpl</code>中与Redis相关的部分代码及其解释：</p><ol><li><strong>获取购物车操作对象</strong>:</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">BoundHashOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCartItemOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">UserInfoTo</span> userInfoTo <span class="token operator">=</span> <span class="token class-name">CartInterceptor</span><span class="token punctuation">.</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>userInfoTo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token class-name">CartConstant</span><span class="token punctuation">.</span><span class="token constant">CART_PREFIX</span> <span class="token operator">+</span> userInfoTo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token class-name">CartConstant</span><span class="token punctuation">.</span><span class="token constant">CART_PREFIX</span> <span class="token operator">+</span> userInfoTo<span class="token punctuation">.</span><span class="token function">getUserKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法根据用户的登录状态返回一个绑定了购物车key的<code>BoundHashOperations</code>对象，用于操作Redis中的购物车数据。</p><ol start="2"><li><strong>获取购物车内容</strong>:</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CartItemVo</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCartByKey</span><span class="token punctuation">(</span><span class="token class-name">String</span> userKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">BoundHashOperations</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> ops <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token class-name">CartConstant</span><span class="token punctuation">.</span><span class="token constant">CART_PREFIX</span><span class="token operator">+</span>userKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> ops<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>values <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CartItemVo</span><span class="token punctuation">&gt;</span></span> cartItemVos <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>obj <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> json <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> <span class="token class-name">CartItemVo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> cartItemVos<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法根据提供的key（可以是用户ID或<code>user-key</code>）从Redis中获取购物车的内容，并将其转换为<code>CartItemVo</code>对象的列表。</p><ol start="3"><li><strong>合并购物车</strong>:</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">CartVo</span> <span class="token function">getCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CartVo</span> cartVo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CartVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">UserInfoTo</span> userInfoTo <span class="token operator">=</span> <span class="token class-name">CartInterceptor</span><span class="token punctuation">.</span>threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CartItemVo</span><span class="token punctuation">&gt;</span></span> tempCart <span class="token operator">=</span> <span class="token function">getCartByKey</span><span class="token punctuation">(</span>userInfoTo<span class="token punctuation">.</span><span class="token function">getUserKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>userInfoTo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cartVo<span class="token punctuation">.</span><span class="token function">setItems</span><span class="token punctuation">(</span>tempCart<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CartItemVo</span><span class="token punctuation">&gt;</span></span> userCart <span class="token operator">=</span> <span class="token function">getCartByKey</span><span class="token punctuation">(</span>userInfoTo<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tempCart <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> tempCart<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">CartItemVo</span> cartItemVo <span class="token operator">:</span> tempCart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                userCart<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cartItemVo<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">addCartItem</span><span class="token punctuation">(</span>cartItemVo<span class="token punctuation">.</span><span class="token function">getSkuId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cartItemVo<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        cartVo<span class="token punctuation">.</span><span class="token function">setItems</span><span class="token punctuation">(</span>userCart<span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">CartConstant</span><span class="token punctuation">.</span><span class="token constant">CART_PREFIX</span> <span class="token operator">+</span> userInfoTo<span class="token punctuation">.</span><span class="token function">getUserKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cartVo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法首先检查用户是否已登录。如果用户未登录，直接返回临时购物车的内容。如果用户已登录，会合并临时购物车和用户的购物车，并将合并后的购物车存储在Redis中。</p><p>从上述代码中，我们可以看到购物车的数据确实是存储在Redis中的，使用哈希结构来存储每个购物车项。这种设计可以确保购物车的操作速度快，同时也方便合并临时购物车和用户的购物车。</p><h2 id="_50、购物车中存储的了用户的购物车-当商品的数量很多时-redis可能会被挤满-如果redis宕机-那么用户的购物车数据就会消失-这样风险很大" tabindex="-1"><a class="header-anchor" href="#_50、购物车中存储的了用户的购物车-当商品的数量很多时-redis可能会被挤满-如果redis宕机-那么用户的购物车数据就会消失-这样风险很大" aria-hidden="true">#</a> 50、购物车中存储的了用户的购物车，当商品的数量很多时，redis可能会被挤满，如果redis宕机，那么用户的购物车数据就会消失，这样风险很大</h2><p>您提到的问题确实是在使用Redis作为购物车存储时需要考虑的。Redis虽然提供了快速的读写性能，但它是一个内存数据库，所以存储空间是有限的。此外，由于它主要存储在内存中，如果没有适当的持久化策略或备份策略，数据可能会在Redis宕机或重启时丢失。</p><p>为了解决这些问题，可以考虑以下策略：</p><ol><li><p><strong>持久化</strong>:</p><ul><li>Redis提供了几种持久化机制，如RDB快照和AOF日志。可以根据业务需求选择合适的持久化策略，以确保数据的安全。</li><li>RDB会在指定的时间间隔内生成数据集的时间点快照。</li><li>AOF会记录服务器接收到的每个写操作，重启时会重新执行这些命令来恢复数据。</li></ul></li><li><p><strong>备份</strong>:</p><ul><li>定期备份Redis数据，确保在数据丢失时可以从备份中恢复。</li><li>可以考虑使用云服务提供商提供的备份和恢复服务。</li></ul></li><li><p><strong>分片</strong>:</p><ul><li>如果数据量非常大，可以考虑使用Redis的分片功能，将数据分布到多个Redis实例上。</li><li>这样可以有效地扩展存储容量和处理能力。</li></ul></li><li><p><strong>混合存储策略</strong>:</p><ul><li>考虑将购物车数据存储在关系数据库或其他持久化存储中，而不是完全依赖Redis。</li><li>Redis可以用作缓存层，提供快速的读写访问，而持久化存储可以确保数据的安全和持久性。</li></ul></li><li><p><strong>监控和警告</strong>:</p><ul><li>使用监控工具监控Redis的内存使用情况，当接近上限时发送警告。</li><li>这样可以提前采取措施，避免因内存不足而导致的问题。</li></ul></li><li><p><strong>数据清理策略</strong>:</p><ul><li>定期清理旧的或不再需要的购物车数据，释放存储空间。</li><li>可以设置TTL（生存时间）来自动删除过期的数据。</li></ul></li></ol><p>虽然使用Redis存储购物车数据有其优势，但也需要考虑其潜在的风险，并采取适当的策略来确保数据的安全和可靠性。</p><p><strong>弄清楚shiro、SpringSecurity、单点登录、outh2，完成一道算法题、投递简历</strong></p>`,136),p=[o];function i(l,c){return s(),a("div",null,p)}const d=n(e,[["render",i],["__file","商城项目自我测试.html.vue"]]);export{d as default};
