import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,b as s}from"./app-5a397b47.js";const t={},i=s(`<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java" aria-hidden="true">#</a> Java：</h1><h2 id="linkedlist和arraylist有什么区别-底层结构有什么区别" tabindex="-1"><a class="header-anchor" href="#linkedlist和arraylist有什么区别-底层结构有什么区别" aria-hidden="true">#</a> - LinkedList和ArrayList有什么区别，底层结构有什么区别</h2><h2 id="concurrenthashmap如何解决线程同步问题的" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap如何解决线程同步问题的" aria-hidden="true">#</a> - ConcurrentHashMap如何解决线程同步问题的</h2><p>ConcurrentHashMap在JDK1.7之前是通过分段式锁来方式来解决线程同步的问题的，在JDK1.8以后就变成了CAS+Synchronized来解决的</p><p>1.7分段锁：从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment</p><p>数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本</p><p>身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</p><p>实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就</p><p>是支持16个线程的并发写，Segment之间相互不会受到影响。</p><p><strong>put</strong>流程</p><p>整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过</p><p>ReentrantLock去操作而已，后面的流程，就和HashMap基本上是一样的。</p><p><strong>1.</strong> 计算hash，定位到segment，segment如果是空就先初始化</p><p><strong>2.</strong> 使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获</p><p>取，保证一定获取锁成功</p><p><strong>3.</strong> 遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存</p><p>在就再插入链表，链表同样操作</p><p><strong>get</strong>流程</p><p>get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要</p><p>注意的是value是volatile的，所以get是不需要加锁的。</p><figure><img src="https://local-imge.oss-cn-beijing.aliyuncs.com/images/image-20230908111135152.png" alt="image-20230908111135152" tabindex="0" loading="lazy"><figcaption>image-20230908111135152</figcaption></figure><p><strong>1.8 CAS+synchronized</strong></p><p>jdk1.8实现线程安全不是在数据结构上下功夫，它的数据结构和HashMap是一样的，</p><p>数组+链表+红黑树。它实现线程安全的关键点在于put流程。</p><p><strong>put</strong>流程</p><p><strong>1.</strong> 首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</p><p>2.如果当前数组位置是空则直接通过CAS自旋写入数据</p><p><strong>3.</strong> 如果hash==MOVED，说明需要扩容，执行扩容</p><p><strong>4.</strong> 如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑</p><p>树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链</p><p>表长度超过8就转换成红黑树</p><figure><img src="https://local-imge.oss-cn-beijing.aliyuncs.com/images/image-20230908111043912.png" alt="image-20230908111043912" tabindex="0" loading="lazy"><figcaption>image-20230908111043912</figcaption></figure><p><strong>get</strong>查询</p><p>get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，</p><p>如果是红黑树按照红黑树获取，否则就遍历链表获取。</p><h2 id="为什么用synchronized关键字-不用reentrantlock" tabindex="-1"><a class="header-anchor" href="#为什么用synchronized关键字-不用reentrantlock" aria-hidden="true">#</a> - 为什么用Synchronized关键字，不用Reentrantlock</h2><h3 id="concurrenthashmap-在-jdk-1-7-和-jdk-1-8-中的锁机制变化" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-在-jdk-1-7-和-jdk-1-8-中的锁机制变化" aria-hidden="true">#</a> ConcurrentHashMap 在 JDK 1.7 和 JDK 1.8 中的锁机制变化</h3><p>确实，从 JDK 1.7 到 JDK 1.8，<code>ConcurrentHashMap</code> 的内部实现发生了显著的变化。在 JDK 1.7 中，<code>ConcurrentHashMap</code> 使用了分段锁技术，每个段（Segment）都是一个独立的哈希表，并且每个段都有自己的锁（使用 <code>ReentrantLock</code>）。这样，多个线程可以同时写入不同的段，从而实现高并发性。</p><p>然而，在 JDK 1.8 中，<code>ConcurrentHashMap</code> 的设计者们决定放弃分段锁技术，转而使用一个更简单、更扁平的数据结构，并结合了 <code>synchronized</code> 和 CAS 来实现并发控制。</p><p>以下是为什么在 JDK 1.8 中选择 <code>synchronized</code> 而不是 <code>ReentrantLock</code> 的原因：</p><ol><li><p><strong>简化设计</strong>：使用 <code>synchronized</code> 可以简化代码，使其更易于维护。<code>ReentrantLock</code> 虽然提供了更多的功能和更细粒度的控制，但在 <code>ConcurrentHashMap</code> 的上下文中，这些额外的功能并不总是必要的。</p></li><li><p><strong>JVM 优化</strong>：随着 JVM 的进化，<code>synchronized</code> 的性能得到了显著的提高。尤其是在轻量级锁和偏向锁的优化下，<code>synchronized</code> 的开销变得非常小，特别是在竞争不激烈的情况下。</p></li><li><p><strong>减少对象的开销</strong>：使用 <code>ReentrantLock</code> 会为每个段创建一个额外的对象，而使用 <code>synchronized</code> 则不需要。这有助于减少内存开销。</p></li><li><p><strong>局部性原理</strong>：在 JDK 1.8 的实现中，与特定键关联的锁通常是与该键关联的节点对象。这意味着锁对象和数据通常会在内存中彼此靠近，从而更好地利用局部性原理，提高缓存效率。</p></li></ol><div class="language-markdown line-numbers-mode" data-ext="md"><pre class="language-markdown"><code><span class="token bold"><span class="token punctuation">**</span><span class="token content">答案</span><span class="token punctuation">**</span></span>:
在 JDK 1.8 中，<span class="token code-snippet code keyword">\`ConcurrentHashMap\`</span> 选择使用 <span class="token code-snippet code keyword">\`synchronized\`</span> 而不是 <span class="token code-snippet code keyword">\`ReentrantLock\`</span> 主要是因为设计的简化、JVM 对 <span class="token code-snippet code keyword">\`synchronized\`</span> 的优化、减少对象的内存开销以及更好地利用局部性原理。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>总的来说，JDK 1.8 中的 <code>ConcurrentHashMap</code> 选择了一个更简单、更高效的并发控制策略，以适应其新的内部数据结构。</p><h2 id="aqs介绍一下-如何实现非公平锁和公平锁" tabindex="-1"><a class="header-anchor" href="#aqs介绍一下-如何实现非公平锁和公平锁" aria-hidden="true">#</a> - AQS介绍一下，如何实现非公平锁和公平锁</h2><p>new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。非公平锁和公平锁的两处不同：</p><p><strong>1.</strong> 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</p><p><strong>2.</strong> 非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL：</h1><h2 id="聚簇索引和非聚簇索引有什么区别-回表是什么意思" tabindex="-1"><a class="header-anchor" href="#聚簇索引和非聚簇索引有什么区别-回表是什么意思" aria-hidden="true">#</a> - 聚簇索引和非聚簇索引有什么区别，回表是什么意思</h2><h2 id="b-树的结构-有什么好处" tabindex="-1"><a class="header-anchor" href="#b-树的结构-有什么好处" aria-hidden="true">#</a> - B+树的结构，有什么好处</h2><h2 id="mysql默认隔离级别是什么-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#mysql默认隔离级别是什么-解决了什么问题" aria-hidden="true">#</a> - MySQL默认隔离级别是什么，解决了什么问题</h2><h2 id="mvcc是什么-有什么用" tabindex="-1"><a class="header-anchor" href="#mvcc是什么-有什么用" aria-hidden="true">#</a> - MVCC是什么，有什么用</h2><p>MVCC又叫多版本并发控制，通过版本链来控制，在MYSQL的默认隔离级别中，通过MVCC和临建锁来解决幻读问题</p><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li><li><img src="https://local-imge.oss-cn-beijing.aliyuncs.com/images/image-20230908120756888.png" alt="image-20230908120756888" tabindex="0" loading="lazy"><figcaption>image-20230908120756888</figcaption></li></ul><p>Read View 有四个重要的字段：</p><ul><li><p>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</p></li><li><p>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</p></li><li><p>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</p></li><li><p>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</p></li><li><figure><img src="https://local-imge.oss-cn-beijing.aliyuncs.com/images/image-20230908120846416.png" alt="image-20230908120846416" tabindex="0" loading="lazy"><figcaption>image-20230908120846416</figcaption></figure></li><li><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li><p>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p></li><li><p>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p></li><li><p>如果记录的 trx_id 值在 Read View 的</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>min_trx_id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>和</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>max_trx_id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>之间，需要判断 trx_id 是否在 m_ids 列表中：</p><ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul></li></ul><h1 id="算法题" tabindex="-1"><a class="header-anchor" href="#算法题" aria-hidden="true">#</a> 算法题：</h1><h2 id="左右括号匹配" tabindex="-1"><a class="header-anchor" href="#左右括号匹配" aria-hidden="true">#</a> - 左右括号匹配</h2>`,64),o=[i];function r(c,d){return a(),e("div",null,o)}const g=n(t,[["render",r],["__file","得物一面0908.html.vue"]]);export{g as default};
