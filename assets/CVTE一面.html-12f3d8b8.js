import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as h,b as r}from"./app-aa103f3b.js";const n={},d=r('<h2 id="自我介绍" tabindex="-1"><a class="header-anchor" href="#自我介绍" aria-hidden="true">#</a> 自我介绍</h2><h2 id="问实习-具体场景-针对自己负责的模块进行解释-为什么要那么做-还问到设计模式" tabindex="-1"><a class="header-anchor" href="#问实习-具体场景-针对自己负责的模块进行解释-为什么要那么做-还问到设计模式" aria-hidden="true">#</a> 问实习（具体场景，针对自己负责的模块进行解释，为什么要那么做，还问到设计模式）</h2><h2 id="hashmap结构以及put流程" tabindex="-1"><a class="header-anchor" href="#hashmap结构以及put流程" aria-hidden="true">#</a> hashmap结构以及put流程</h2><h2 id="concurrenthashmap的结构" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap的结构" aria-hidden="true">#</a> ConcurrentHashMap的结构</h2><h2 id="为什么concurrenthashmap要把锁从reentrantlock换成synchronized-cas锁" tabindex="-1"><a class="header-anchor" href="#为什么concurrenthashmap要把锁从reentrantlock换成synchronized-cas锁" aria-hidden="true">#</a> 为什么ConcurrentHashMap要把锁从ReentrantLock换成Synchronized+CAS锁</h2><p>在Java 8之前的版本中，ConcurrentHashMap使用了一种基于分段锁（Segment）的设计，每个段都由一个ReentrantLock来保护。这种设计在提供一定的并发性能的同时，也引入了一些开销，比如每个段都需要维护一个独立的锁。</p><p>Java 8引入了一种新的并发编程方式，即使用CAS（Compare and Swap）操作和synchronized关键字的组合，来替代ReentrantLock的使用。CAS是一种无锁算法，它使用原子性的操作来实现并发控制，而不需要显式地使用锁。</p><p>通过将ReentrantLock替换为CAS+synchronized的组合，ConcurrentHashMap在Java 8中获得了更好的并发性能。这种改变的主要原因有以下几点：</p><ol><li><p>减少锁的粒度：使用分段锁的方式，每个段都需要维护一个独立的锁，这会增加锁的粒度，可能导致较高的锁竞争。而CAS+synchronized的组合方式可以减少锁的粒度，提高并发性能。</p></li><li><p>无锁算法的优势：CAS是一种无锁算法，它利用原子性的操作来实现并发控制，避免了传统锁机制中的锁竞争和上下文切换的开销。这使得ConcurrentHashMap在高并发场景下具有更好的性能和可伸缩性。</p></li><li><p>简化设计和实现：使用CAS+synchronized的组合方式可以简化ConcurrentHashMap的设计和实现。相比于维护多个独立的锁，使用无锁算法可以减少复杂性和潜在的错误。</p></li></ol><p>需要注意的是，CAS+synchronized的组合方式并不是适用于所有情况的最佳选择。具体的并发控制策略需要根据应用程序的需求和具体的并发访问模式来选择。在某些特定的场景中，使用其他的并发控制算法或数据结构可能更加适合。</p><h2 id="concurrenthashmap的put流程" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap的put流程" aria-hidden="true">#</a> concurrentHashMap的put流程</h2><h2 id="concurrenthashmap的锁加在哪里" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap的锁加在哪里" aria-hidden="true">#</a> ConcurrentHashMap的锁加在哪里？</h2><h2 id="如果两个线程并发修改hash值相同-key不同的值-会加锁吗" tabindex="-1"><a class="header-anchor" href="#如果两个线程并发修改hash值相同-key不同的值-会加锁吗" aria-hidden="true">#</a> 如果两个线程并发修改hash值相同，key不同的值，会加锁吗？</h2><h2 id="说一下concurrenthashmap是如何进行加锁的" tabindex="-1"><a class="header-anchor" href="#说一下concurrenthashmap是如何进行加锁的" aria-hidden="true">#</a> 说一下ConcurrentHashMap是如何进行加锁的</h2><h2 id="说一下synchronized的锁升级过程" tabindex="-1"><a class="header-anchor" href="#说一下synchronized的锁升级过程" aria-hidden="true">#</a> 说一下synchronized的锁升级过程</h2><h2 id="如果在concurrenthashmap进行cas自旋获取不到锁-会怎么办" tabindex="-1"><a class="header-anchor" href="#如果在concurrenthashmap进行cas自旋获取不到锁-会怎么办" aria-hidden="true">#</a> 如果在ConcurrentHashMap进行CAS自旋获取不到锁，会怎么办？</h2><h2 id="volatile有了解吗" tabindex="-1"><a class="header-anchor" href="#volatile有了解吗" aria-hidden="true">#</a> volatile有了解吗？</h2><h2 id="volatile解决了什么问题" tabindex="-1"><a class="header-anchor" href="#volatile解决了什么问题" aria-hidden="true">#</a> volatile解决了什么问题？</h2><h2 id="jvm有了解吗-说一下内存区域的划分" tabindex="-1"><a class="header-anchor" href="#jvm有了解吗-说一下内存区域的划分" aria-hidden="true">#</a> JVM有了解吗？说一下内存区域的划分</h2><h2 id="说一下垃圾回收器g1和其他垃圾回收器的区别" tabindex="-1"><a class="header-anchor" href="#说一下垃圾回收器g1和其他垃圾回收器的区别" aria-hidden="true">#</a> 说一下垃圾回收器G1和其他垃圾回收器的区别</h2><h2 id="如果一个对象很大-新生代装不下了-会发生什么" tabindex="-1"><a class="header-anchor" href="#如果一个对象很大-新生代装不下了-会发生什么" aria-hidden="true">#</a> 如果一个对象很大，新生代装不下了，会发生什么？</h2><h2 id="如果分配一个大对象-并且到达老年代内存的90-会发生什么" tabindex="-1"><a class="header-anchor" href="#如果分配一个大对象-并且到达老年代内存的90-会发生什么" aria-hidden="true">#</a> 如果分配一个大对象，并且到达老年代内存的90%会发生什么？</h2><h2 id="说一下spring" tabindex="-1"><a class="header-anchor" href="#说一下spring" aria-hidden="true">#</a> 说一下Spring</h2><h2 id="springboot的自动装配原理" tabindex="-1"><a class="header-anchor" href="#springboot的自动装配原理" aria-hidden="true">#</a> SpringBoot的自动装配原理</h2><h2 id="http状态码-针对503提出的问题" tabindex="-1"><a class="header-anchor" href="#http状态码-针对503提出的问题" aria-hidden="true">#</a> http状态码，针对503提出的问题</h2><h2 id="压测排查问题的流程" tabindex="-1"><a class="header-anchor" href="#压测排查问题的流程" aria-hidden="true">#</a> 压测排查问题的流程</h2><h2 id="平时使用redis的场景是什么" tabindex="-1"><a class="header-anchor" href="#平时使用redis的场景是什么" aria-hidden="true">#</a> 平时使用redis的场景是什么？</h2><h2 id="redis的hash结构" tabindex="-1"><a class="header-anchor" href="#redis的hash结构" aria-hidden="true">#</a> redis的hash结构？</h2><h2 id="redis的string结构" tabindex="-1"><a class="header-anchor" href="#redis的string结构" aria-hidden="true">#</a> Redis的string结构？</h2><h2 id="反问" tabindex="-1"><a class="header-anchor" href="#反问" aria-hidden="true">#</a> 反问</h2>',30),i=[d];function t(s,c){return e(),h("div",null,i)}const u=a(n,[["render",t],["__file","CVTE一面.html.vue"]]);export{u as default};
